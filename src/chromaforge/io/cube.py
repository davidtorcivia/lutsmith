"""Adobe .cube 3D LUT file reader and writer.

The .cube format iterates R fastest (inner loop), then G, then B (outer loop).
Our LUT convention: lut[r, g, b, ch] with flat_index = b*N*N + g*N + r.

Security:
    - Line count limits during parsing
    - Float validation (reject NaN/Inf)
    - Size bounds checking
"""

from __future__ import annotations

import logging
from pathlib import Path

import numpy as np

from chromaforge.config import MAX_CUBE_SIZE, MAX_CUBE_FILE_LINES
from chromaforge.errors import LUTFormatError, ExportError
from chromaforge.io.image import validate_output_path

logger = logging.getLogger(__name__)


def write_cube(
    filepath: str | Path,
    lut: np.ndarray,
    title: str = "",
    domain_min: tuple[float, float, float] = (0.0, 0.0, 0.0),
    domain_max: tuple[float, float, float] = (1.0, 1.0, 1.0),
    kernel_hint: str = "tetrahedral",
) -> Path:
    """Write a 3D LUT in Adobe .cube format.

    Data ordering: R varies fastest (inner loop), then G, then B (outer loop).

    Args:
        filepath: Output file path.
        lut: (N, N, N, 3) array indexed as [r, g, b, ch].
        title: Optional LUT title.
        domain_min: Input domain minimum (R, G, B).
        domain_max: Input domain maximum (R, G, B).
        kernel_hint: Documented in header comment.

    Returns:
        Resolved output path.
    """
    path = validate_output_path(filepath)
    N = lut.shape[0]

    if lut.shape != (N, N, N, 3):
        raise ExportError(f"LUT shape must be (N, N, N, 3), got {lut.shape}")
    if N > MAX_CUBE_SIZE:
        raise ExportError(f"LUT size {N} exceeds maximum {MAX_CUBE_SIZE}")

    lines = []
    if title:
        lines.append(f'TITLE "{title}"')
    lines.append("# Generated by ChromaForge")
    lines.append(f"# Optimized for {kernel_hint} interpolation")
    lines.append("")
    lines.append(f"LUT_3D_SIZE {N}")
    lines.append(
        f"DOMAIN_MIN {domain_min[0]:.6f} {domain_min[1]:.6f} {domain_min[2]:.6f}"
    )
    lines.append(
        f"DOMAIN_MAX {domain_max[0]:.6f} {domain_max[1]:.6f} {domain_max[2]:.6f}"
    )
    lines.append("")

    # R fastest, G next, B slowest
    for bi in range(N):
        for gi in range(N):
            for ri in range(N):
                rv, gv, bv = lut[ri, gi, bi]
                lines.append(f"{rv:.6f} {gv:.6f} {bv:.6f}")

    with open(path, "w", newline="\n") as f:
        f.write("\n".join(lines))
        f.write("\n")

    logger.info("Wrote .cube: %s (size=%d)", path, N)
    return path


def read_cube(filepath: str | Path) -> tuple[np.ndarray, dict]:
    """Parse an Adobe .cube file.

    Args:
        filepath: Path to .cube file.

    Returns:
        (lut, metadata): (N, N, N, 3) array indexed as [r, g, b, ch]
            and metadata dict with title, domain_min, domain_max, size.

    Raises:
        LUTFormatError: If file is malformed.
    """
    path = Path(filepath).resolve()
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")

    size = None
    domain_min = [0.0, 0.0, 0.0]
    domain_max = [1.0, 1.0, 1.0]
    title = ""
    values = []
    line_count = 0

    with open(path, "r") as f:
        for raw_line in f:
            line_count += 1
            if line_count > MAX_CUBE_FILE_LINES:
                raise LUTFormatError(
                    f"File exceeds maximum line count ({MAX_CUBE_FILE_LINES})"
                )

            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue

            upper = line.upper()

            if upper.startswith("TITLE"):
                if '"' in line:
                    title = line.split('"')[1]
                else:
                    title = line[6:].strip()

            elif upper.startswith("LUT_3D_SIZE"):
                try:
                    size = int(line.split()[-1])
                except (ValueError, IndexError):
                    raise LUTFormatError(f"Invalid LUT_3D_SIZE: {line}")
                if size < 2 or size > MAX_CUBE_SIZE:
                    raise LUTFormatError(
                        f"LUT_3D_SIZE {size} out of range [2, {MAX_CUBE_SIZE}]"
                    )

            elif upper.startswith("DOMAIN_MIN"):
                try:
                    parts = line.split()[1:4]
                    domain_min = [float(p) for p in parts]
                except (ValueError, IndexError):
                    raise LUTFormatError(f"Invalid DOMAIN_MIN: {line}")

            elif upper.startswith("DOMAIN_MAX"):
                try:
                    parts = line.split()[1:4]
                    domain_max = [float(p) for p in parts]
                except (ValueError, IndexError):
                    raise LUTFormatError(f"Invalid DOMAIN_MAX: {line}")

            elif upper.startswith("LUT_1D_SIZE"):
                # Skip 1D LUT entries (we only handle 3D)
                continue

            else:
                # Try to parse as data triplet
                parts = line.split()
                if len(parts) >= 3:
                    try:
                        triplet = [float(parts[0]), float(parts[1]), float(parts[2])]
                    except ValueError:
                        continue  # Skip unparseable lines

                    # Validate: no NaN or Inf
                    for v in triplet:
                        if not np.isfinite(v):
                            raise LUTFormatError(
                                f"Non-finite value in .cube data at line {line_count}"
                            )

                    values.append(triplet)

    if size is None:
        raise LUTFormatError("No LUT_3D_SIZE found in .cube file")

    expected = size ** 3
    if len(values) != expected:
        raise LUTFormatError(
            f"Expected {expected} data entries for size {size}, got {len(values)}"
        )

    # Data is ordered R-fastest, G-next, B-slowest.
    # Sequential entries: [b=0,g=0,r=0], [b=0,g=0,r=1], ..., [b=0,g=0,r=N-1],
    #                     [b=0,g=1,r=0], ..., [b=N-1,g=N-1,r=N-1]
    # Reshape flat array to (B, G, R, 3) then transpose to (R, G, B, 3).
    raw = np.array(values, dtype=np.float32)  # (N^3, 3)
    lut_bgr = raw.reshape((size, size, size, 3))  # [b, g, r, ch]
    lut = np.transpose(lut_bgr, (2, 1, 0, 3))  # [r, g, b, ch]

    metadata = {
        "title": title,
        "domain_min": domain_min,
        "domain_max": domain_max,
        "size": size,
    }

    logger.info("Read .cube: %s (size=%d)", path, size)
    return lut, metadata
